\documentclass{article}
\usepackage[margin=1in]{geometry}

\input{'../def.tex'}
\newcommand{\spin}{\textsc{Spin}}
\newcommand{\promela}{\textsc{Promela}}

\begin{document}
\summary{The Model Checker \spin}
\onehalfspacing

%% Focus on practical things, expressiveness
First impressions: this is very cool work.
The specification language seems expressive and high-level,
 the verification routine is straightforward (no complicated heuristics),
 and the promise of finding bugs in hard-to-debug concurrent software is great.
Section 4 gives a range of difficult and just-small-enough concurrency problems
 to make me want to try using \spin, and Section 4.4 tells me where to look for
 the big applications.
Moreover, knowing that this paper was written ~5 years after \spin\ was first released
 makes me believe the tool is well-designed and useful.
It's also nice to see the \spin\ workshop is still alive.

Going deeper, Section 3 is also exciting.
First off, it seems a little like magic that the core algorithm is just cycle finding.
Re-reading Section 2 takes away the magic, except for how Vardi \& Wolper
 discovered the LTL / B\"uchi automata connection.
I'm relieved to know that \spin\ take LTL formulas as input, rather than
 B\"uchi automata\textemdash one less source of error, though it's not the big
 step of compiling the model to C.
Partial order reduction makes sense, but I hope we have time to go over
 the memory optimizations in class.

Overall \spin\ seems like an A+ tool~\cite{h-spin}.
Model checking sounds great.

One surprise though: I was expecting to find a section on pruning
 counterexamples\textemdash taking a trace generated by \spin\ and trying to
 reduce it before handing off to the user.
Now that I know how counterexampes are generated, this is less surprising
 because I can see how a time/space efficient cycle-finding algorithm would
 be likely to find short cycles, but I'm still skeptical that people using
 \spin\ on very large programs are fine without support for parsing the
 counterexample or tracing execution through the automata.

Speaking of which, is it easy to print these generated automata?
Recently I tried the Kleenex tool from this year's POPL~\cite{ghrst-kleenex}, and my one complaint
 is that match errors are impossible to debug.
Maybe I have a problem with the grammar or maybe my input is bad, but
 all I get from Kleenex is "match error at node N".
That would be okay if I could relate the matcher automata to my input, but
 that does not seem to be implemented.

% Given the paper came out after 10 years of SPIN in the battlefield,
% I'd be surrpised if I DIDN"T like it

\subsubsection*{Questions}
\begin{itemize}
\item
  Can today's \spin\ generate C source code from a model?
\item
  Are there serious competitors to \spin ?
  If so, what are their relative advantages?
\item
  What are some interesting properties we cannot express in LTL?
\end{itemize}

\subsubsection*{Comments}
\begin{itemize}
\item
  Pretty funny that \promela\ has {\tt printf}.
  Old habits die hard?
\item
  Does \promela\ not have line comments?
\end{itemize}


\footnotesize
\bibliographystyle{plain}
\bibliography{h-spin}
\end{document}
