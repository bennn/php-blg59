\section{From C to Asm}
\label{sec:passes}

The CompCert compiler is divided across 25 passes.
\figref{structure} shows 21 of these; the missing passes are additional optimizations.

In the beginning there is C99; the end is PowerPC, ARM, or x86 32-bit assembly.
Here we follow the path of C programs down to assembly.\footnote{\intel, specifically, but the story for PowerPC and ARM is similar and, according to the authors, more efficient. ``The IA32 architecture, with its paucity of registers and inefficient calling conventions, is not a good fit for the CompCert compilation model.''~\cite{refman}}

Following the diagram, this section is divided into 3 parts: front-end, back-end, and assembly.
Our final reference for each pass is the annotated Coq development~\cite{src}.
Inline hyperlinks point to specific lines in the Coq source; these may go stale, but are relevant as of \today.


\subsection{C Front-End}
%% \footnote{The name {\tt cfrontend} is from the compiler's source code, maybe in hopes of adding another {\tt langfrontend} some day.}

``CompCert C'' programs are normal C programs.
Case in point, we start with classic fibonacci:
\begin{lstlisting}
#include <stdlib.h>
#include <stdio.h>

#define NDEFAULT 36

int fib(int n) {
  if (n < 2)  return 1;
  else  return fib(n-1) + fib(n-2);
}

int main(int argc, char ** argv) {
  int n, r;
  if (argc >= 2) n = atoi(argv[1]); else n = NDEFAULT;
  r = fib(n);
  printf("fib(%d) = %d\n", n, r);
  return 0;
}
\end{lstlisting}
The libraries \lstinline{stdlib.h} and \lstinline{stdio.h} are the system-standard C libraries, not specialized CompCert versions.
The \lstinline{#define} directive is expanded by a preprocessor.
The \lstinline{main} function accepts a variable number of arguments on the command line.
Calling \lstinline{printf} prints a string to the console.
Even the command to compile this program is (nearly) indistinguishable from the {\tt gcc} equivalent.

\vspace{1mm}
\hfill{}\lstinline{ccomp -o fib fibonacci.c}\hfill{}vs.\hfill{}\lstinline{gcc -o fib fibonacci.c}\hfill{}
\vspace{1mm}

The resulting executables are also similar, though the CompCert version runs slightly faster\footnote{5\% faster, averaging over 10 runs of \lstinline{./fib 52}.} due to having at least some optimizations.
Changing to {\tt gcc -O2} leaves CompCert in the dust; it is almost 50\% faster.

Point being, CompCert C really is just a subset of familiar C and many programs
As stated in Section 1, the subset does not include threaded programs or {\tt setjump} or \lstinline{long double} types, but it is a large subset nonetheless.


\subsubsection{Preprocessing}

Compilation begins with \href{https://github.com/AbsInt/CompCert/blob/master/driver/Driver.ml#L272}{preprocessing}.
CompCert invokes a system preprocessor (determined in configuration and registered when building CompCert) to interpret macros \& directives.
There is no formal guarantee that the preprocessor's output matches the source code.


\subsubsection{Lexing and Parsing}

\href{https://github.com/AbsInt/CompCert/blob/master/driver/Driver.ml#L129}{After} preprocessing, the entire C source file is \href{https://github.com/AbsInt/CompCert/blob/master/cparser/Parse.ml#L56}{loaded} into memory and sent to a \href{https://github.com/AbsInt/CompCert/blob/master/cparser/Parser.vy}{parsing automaton}.
The \href{https://github.com/AbsInt/CompCert/blob/master/cparser/Lexer.mll}{lexer} and \href{https://github.com/AbsInt/CompCert/blob/master/cparser/Parser.vy}{parser}
 automata are generated by the Menhir parser generator~\cite{pr-menhir} from a \href{https://github.com/AbsInt/CompCert/blob/master/cparser/pre\_parser.mly}{C grammar}.

Lexing is apparently unverified, but the parser is guaranteed faithful to the \href{https://github.com/AbsInt/CompCert/blob/master/cparser/validator/Main.v#L38}{grammar} from which it was generated.
This means that the parser accepts the same language as the specification grammar.
Assuming the grammar correctly recognizes C99, we have a verfied C99 parser.


\subsubsection{Pragmas}

The parsed C AST is sent through a ``\href{https://github.com/AbsInt/CompCert/blob/master/cfrontend/C2C.ml}{C2C}'' tranformation to typecheck the AST and expand CompCert pragmas.
This pass is implemented in OCaml and does not have a formal guarantee.

The \href{https://github.com/AbsInt/CompCert/blob/master/cfrontend/Ctypes.v#L69}{types} are simple C types.
\begin{lstlisting}[style=Coq]
Inductive type : Type :=
  | Tvoid: type
  | Tint: intsize -> signedness -> attr -> type
  | Tlong: signedness -> attr -> type
  | Tfloat: floatsize -> attr -> type
  | Tpointer: type -> attr -> type
  | Tarray: type -> Z -> attr -> type
  | Tfunction: typelist -> type -> calling_convention -> type
  | Tstruct: ident -> attr -> type
  | Tunion: ident -> attr -> type
\end{lstlisting}

The pragmas guide linker execution~\cite{refman}.
\begin{itemize}
\item {\tt reserve\_register} : prevent the compiler from using a specific register in compiled code.
\item {\tt section} : defines a linker section.
\item {\tt use\_section} : explictly place definitions inside a declared section.
\end{itemize}

After this phase, we have a \emph{CompCert C} AST and are ready to begin verified compilation.


\subsection{Back-End}

Every pass in this subsection has a Coq proof of correctness.
All passes and proofs are online and annotated~\cite{src}.

Note: Clight is the front-end described in the CompCert journal and conference publications~\cite{bdl-formal,l-formal}.
Officially, the back-end starts with {\tt Cminor}, but we use ``back-end'' here to group the formally verified core passes of the compiler.


\subsubsection{CompCert C to Clight}
The first verified \href{https://github.com/AbsInt/CompCert/blob/master/cfrontend/SimplExpr.v}{pass} removes side effects out from expressions and into assignment statements.
For example:

\hbox{
\begin{lstlisting}
  int x = 0;
  return  (10 / x) + (x = 1);
\end{lstlisting}
\becomes
\begin{lstlisting}
  int x, y;
  x = 0;
  y = 1;
  x = y;
  return (10 / x) + y;
\end{lstlisting}
}

The translation happens inside a monad for catching errors and generating fresh names (like \lstinline{y}).
If the pass is successful, CompCert asserts that the result is a valid Clight AST and moreover the source and result are related by a \emph{forward simulation}.
(\secref{terminology} will explain the precise meaning of this and other proofs.)
\begin{lstlisting}[style=Coq]
Theorem transl_program_correct:
  forward_simulation (Cstrategy.semantics prog) (Clight.semantics1 tprog).
\end{lstlisting}


\subsubsection{Simplify Locals (Clight to Clight)}
The \href{https://github.com/AbsInt/CompCert/blob/master/cfrontend/SimplLocals.v}{next pass} moves \emph{local scalar variables} whose address is not taken into temporary variables.
The overall goal of this pass is to ensure that functions are only called on temporaries.
Thus if a variable's address is ever taken \emph{and} the variable is used as a function parameter, the function call is rewritten to reference a new temporary variable.
In the end, all function parameters live on the stack when the function call happens.

This pass's correctness \href{https://github.com/AbsInt/CompCert/blob/master/cfrontend/SimplLocalsproof.v#L2390}{theorem} relates two version of the Clight semantics;
 in \lstinline{semantics2}, function parameters may only be temporaries.
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (semantics1 prog) (semantics2 tprog).
\end{lstlisting}


\subsubsection{Clight to C\#minor}
Next, we translate to the \href{https://github.com/AbsInt/CompCert/blob/master/cfrontend/Csharpminor.v}{C\#minor} intermediate language.
The \href{https://github.com/AbsInt/CompCert/blob/master/cfrontend/Cshmgen.v}{pass} resolves all type-dependent behaviors,
 including overloaded function applications and address computations, and converts loop and \lstinline{switch} statements
 to slightly \href{https://github.com/AbsInt/CompCert/blob/master/cfrontend/Cshmgen.v#L581}{simpler} representations.
The pass guarantees that (second version of) the Clight semantics are in forward simulation with the C\#minor semantics.
\begin{lstlisting}[style=Coq]
Theorem transl_program_correct:
  forward_simulation (Clight.semantics2 prog) (Csharpminor.semantics tprog).
\end{lstlisting}


\subsubsection{C\#minor to Cminor}
C\#minor functions may take the address of variables, but Cminor functions have exactly 1 addressable variable (the stack).
This pass moves variables to the stack and \href{https://github.com/AbsInt/CompCert/blob/master/cfrontend/Cminorgen.v#L86}{converts} address lookups to stack lookups.
\begin{lstlisting}[style=Coq]
Theorem transl_program_correct:
  forward_simulation (Csharpminor.semantics prog) (Cminor.semantics tprog).
\end{lstlisting}

Cminor is the last machine-independent intermediate language.
This makes Cminor a reasonable target language for other high-level compilers that want to re-use CompCert's optimizations and assembly.
Recent work on separation logic for Clight~\cite{ab-separation} and a static analyzer for C\#minor~\cite{jlblp-verasco} have given even more reasons to target Cminor.


\subsubsection{Instruction Selection (Cminor to CminorSel)}
The first machine-dependent pass \href{https://github.com/AbsInt/CompCert/blob/master/backend/Selection.v#L70}{recognizes} sequences of operations that the target machine can perform in one instruction.
On \intel, the sum {\tt n1 + n2} will \href{https://github.com/AbsInt/CompCert/blob/master/ia32/SelectOp.vp#L90}{translate} to an immediate-add instruction if one of the operands is a constant.
This pass also \href{https://github.com/AbsInt/CompCert/blob/master/backend/Selection.v#L54}{converts} loads and stores to the target architecture's addressing modes.

The CminorSel semantics are tailored to a particular target language, but the overall \href{https://github.com/AbsInt/CompCert/blob/master/backend/Selectionproof.v#L1038}{theorem} is similar to earlier passes.
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forall prog tprog,
  sel_program prog = OK tprog ->
  forward_simulation (Cminor.semantics prog) (CminorSel.semantics tprog).
\end{lstlisting}

The pass will fail in the translation step \lstinline{sel_program} if the target architecture is \href{https://github.com/AbsInt/CompCert/blob/master/backend/Selection.v#L387}{missing} required operations (in particular, 64-bit arithmetic).


\subsubsection{CFG generation (CminorSel to RTL)}
After instruction selection, CompCert \href{https://github.com/AbsInt/CompCert/blob/master/backend/RTLgen.v}{builds} a control-flow graph of the program.
The pass includes a \href{https://github.com/AbsInt/CompCert/blob/master/backend/RTLgenaux.ml}{heuristic} based on the size of programs for choosing which branch of an \lstinline{if}-statement should be the fall-through case.
\begin{lstlisting}[style=Coq]
| Sifthenelse c strue sfalse =>
    if more_likely c strue sfalse then
      do nfalse <- transl_stmt map sfalse nd nexits ngoto nret rret;
      do ntrue  <- transl_stmt map strue  nd nexits ngoto nret rret;
         transl_condexpr map c ntrue nfalse
    else
      do ntrue  <- transl_stmt map strue  nd nexits ngoto nret rret;
      do nfalse <- transl_stmt map sfalse nd nexits ngoto nret rret;
         transl_condexpr map c ntrue nfalse
\end{lstlisting}
Again, the \href{https://github.com/AbsInt/CompCert/blob/master/backend/RTLgenproof.v#L1578}{proof} of correctness is by forward simulation.
%% https://github.com/AbsInt/CompCert/blob/master/backend/RTLgenproof.v#L1578
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (CminorSel.semantics prog) (RTL.semantics tprog).
\end{lstlisting}

The RTL\footnote{RTL stands for ``register transfer language''. The name is \href{http://www.well.com/~cwf/pro/Davidson\%20and\%20Fraser.\%20The\%20design\%20and\%20application\%20of\%20a\%20retargetable\%20peephole\%20optimizer.pdf}{historical}.
                 GCC has an \href{http://gcc.gnu.org/onlinedocs/gccint/RTL.html}{RTL} intermediate language and textbooks often use an RTL~\cite{munchnik}.}
  \href{https://github.com/AbsInt/CompCert/blob/master/backend/RTL.v#L47}{language}
 is very simple: just a graph of instructions.
From here we start the heavier optimizing passes of CompCert.


\subsubsection{Tail Call Recognition (RTL to RTL)}
\href{https://github.com/AbsInt/CompCert/blob/master/backend/Tailcall.v}{Converts} some function calls into \emph{tail calls}.
A tail call does not require allocating a new stack frame, saving time and space.
This is possible when the result of the function call is ignored or used immediately, provided the current function has no addressable variables.

CompCert also detects the more complicated tail call patterns, and optimizes the below to a tail call.

\hbox{
\begin{lstlisting}
  x = f(...);
  nop;
  y = x;
  z = y;
  return z;
\end{lstlisting}\becomes\begin{lstlisting}
  return f(...);
\end{lstlisting}
}

This optimization complicates the proof of correctness, since the source and target versions of RTL might not perform the same transitions.
Instead, if a step in the source was optimized away by the target, a well-founded \href{https://github.com/AbsInt/CompCert/blob/master/backend/Tailcallproof.v#L382}{measure} shows that the target code performs fewer function calls.

\newpage
\begin{lstlisting}[style=Coq]
Definition niter
Definition measure (st: state) : nat :=
  match st with
  | State s f sp pc rs m => (List.length s * (niter + 2) + return_measure f.(fn_code) pc + 1)%nat
  | Callstate s f args m => 0%nat
  | Returnstate s v m => (List.length s * (niter + 2))%nat
  end.
\end{lstlisting}

Additionally, the \href{https://github.com/AbsInt/CompCert/blob/master/backend/Tailcallproof.v#L333}{relation} on source and target states allows the target to use more stack frame slots, provided the existing data is unchanged.

The overall proof is another forward simulation.
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (RTL.semantics prog) (RTL.semantics tprog).
\end{lstlisting}


\subsubsection{Function Inlining (RTL to RTL)}
Function inlining rewrites functions declared as \lstinline{inline} at their call site.
There is no smart \href{https://github.com/AbsInt/CompCert/blob/master/backend/Inliningaux.ml}{heuristic} or measure of fuel to guide inlining.
If the \lstinline{inline} keyword is present, the function body is placed in the code.

There are two caveats:
\begin{itemize}
\item
  Inlining increases the size of a function's stack block.
  If the new block is more than the largest representable integer, compilation \href{https://github.com/AbsInt/CompCert/blob/master/backend/Inlining.v#L452}{fails}.
\item
  Recursive functions are inlined exactly once\textemdash recursive calls are \href{https://github.com/AbsInt/CompCert/blob/master/backend/Inlining.v#L272}{never inlined}.
\end{itemize}

Inlining decreases the number of states in the CFG, so another well-founded \href{https://github.com/AbsInt/CompCert/blob/master/backend/Inliningproof.v#L907}{measure} describes how the target state is ``less than'' the source in case there is no longer a target step matching the source step.
The overall \href{https://github.com/AbsInt/CompCert/blob/master/backend/Inliningproof.v#L1321}{theorem} is the same as the last pass: RTL semantics are preserved.
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (RTL.semantics prog) (RTL.semantics tprog).
\end{lstlisting}


\subsubsection{Renumbering the AST (RTL to RTL)}
Upcoming optimizations rely on \href{https://github.com/AbsInt/CompCert/blob/master/backend/Kildall.v#L218}{Kildall's algorithm} for static analysis.
These analyses all proceed by propogating known information from a node in the CFG to its successors; the process repeats until reacing a fixed point.

If CFG nodes are numbered in post-order with respect to their edges, the static analysis phases run a little faster and more efficiently.
This \href{https://github.com/AbsInt/CompCert/blob/master/backend/Renumber.v}{renumbering} pass ensures a post-order numbering;
 it happens after inlining and tail calls because those passes change the structure of the CFG.

Correctness is by forward simulation.
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (RTL.semantics prog) (RTL.semantics tprog).
\end{lstlisting}


\subsubsection{Constant propogation (RTL to RTL)}
Pushes known constants through expressions and assignments.
For example:

\hbox{
\begin{lstlisting}
  int x = 4
    , y = 7 + x + x
    , z = (2 * x) + y + y + 1;
  return z + x - y;
\end{lstlisting}\becomes\begin{lstlisting}
  int x = 4
    , y = 15
    , z = 39;
  return 28;
\end{lstlisting}
}

Constant propogation will also replace operators like \lstinline{+} with cheaper versions if some, but not all, arguments are statically known.

\href{https://github.com/AbsInt/CompCert/blob/master/backend/Constpropproof.v#L615}{Proof} is by forward simulation.
In this case, the well-founded \href{https://github.com/AbsInt/CompCert/blob/master/backend/Constpropproof.v#L372}{measure} is step indexing.
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (RTL.semantics prog) (RTL.semantics tprog).
\end{lstlisting}


\subsubsection{Common subexpression elimination (RTL to RTL)}
Avoids redundant computations.
If two variables are assigned to the same expression, this pass replaces the later use with a variable reference\textemdash like memoization.

\hbox{
\begin{lstlisting}
int r1 = a + b;
int r2 = a + b
\end{lstlisting}\becomes\begin{lstlisting}
int r1 = a + b;
int r2 = r1;
\end{lstlisting}
}

CompCert's CSE is not very powerful.
Small variations in the code will trick it:

\hbox{
\begin{lstlisting}
int r1 = a + b;
int r2 = b + a
\end{lstlisting}\becomes\begin{lstlisting}
int r1 = a + b;
int r2 = b + a;
\end{lstlisting}
}
and function calls are never optimized.

Still, the optimizations that are implemented are also \href{https://github.com/AbsInt/CompCert/blob/master/backend/CSEproof.v#L1233}{proven} to preserve the RTL semantics.
This pass does not change the number of program steps; one transition in the source is \href{https://github.com/AbsInt/CompCert/blob/master/backend/CSEproof.v#L968}{always matched} by a transition in the target.
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (RTL.semantics prog) (RTL.semantics tprog).
\end{lstlisting}


\subsubsection{Dead Code Elimination (RTL to RTL)}
Changes unreachable, or otherwise useless, instructions into no-ops.
This pass can change termination behavior:

\hbox{
\begin{lstlisting}
int y = 4 / 0;
return 4;
\end{lstlisting}\becomes\begin{lstlisting}
noop;
return 4;
\end{lstlisting}
}

CompCert reasons that the source program in this case is \emph{unsound} and allows dead code elimination to proceed.
This reasoning is used within the simulation proof.
Otherwise, the proof statement is straightforward.
Each source step is matched exactly with a target step; however the matching target step is more often a no-op.
%% TODO exactly why unsound okay?
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (RTL.semantics prog) (RTL.semantics tprog).
\end{lstlisting}


\subsubsection{Unused Globals (RTL to RTL)}
Removes unused global variables from the environment.
Source and target steps remain synchronized; the proof only guarantees that steps did not depend on one of the removed globals.
\begin{lstlisting}[style=Coq]
forward_simulation (semantics p) (semantics tp).
\end{lstlisting}


\subsubsection{Register allocation (RTL to LTL)}
Register allocation determines which program variables can fit in machine registers, and which must be stored in memory.
For each function in the program, CompCert uses George \& Appel's \emph{iterated register coalescing} algorithm to assign variables to registers~\cite{ga-iterated}.

This algorithm works by:
\begin{itemize}
\item Splitting the CFG into \emph{live ranges} for variables.
\item Constructing a graph of dependencies between live ranges.
\item Using a heuristic solver to color the graph. If coloring succeeds, finish.
\item If coloring fails, insert store \& load instructions to relax the graph and repeat from step 2.
\end{itemize}
Rather than implement the algorithm in Coq and directly prove its correctness, the CompCert authors use an OCaml \href{https://github.com/AbsInt/CompCert/blob/master/backend/Regalloc.ml}{implementation}.
At runtime, the (extracted) Coq development gives an RTL function AST to the OCaml procedure.
The OCaml code attempts to find a register allocation and either returns a failure code or a solution in the form of an LTL function AST.
Finally, the Coq development validates the result AST against the original function~\cite{rl-validating}.
If the result is correct, this pass succeeds.

The overall proof for this pass is another \href{https://github.com/AbsInt/CompCert/blob/master/backend/Allocproof.v#L2348}{forward simulation}.
In this case, one source step is matched by \href{https://github.com/AbsInt/CompCert/blob/master/backend/Allocproof.v#L1823}{one or more} target steps.
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (RTL.semantics prog) (LTL.semantics tprog).
\end{lstlisting}
%% Lemma step_simulation:
%%   forall S1 t S2, RTL.step ge S1 t S2 -> wt_state S1 ->
%%   forall S1', match_states S1 S1' ->
%%   exists S2', plus LTL.step tge S1' t S2' /\ match_states S2 S2'.

The result of this pass is an \href{https://github.com/AbsInt/CompCert/blob/master/backend/LTL.v}{LTL} program, meaning the program uses machine registers and stack slots rather than pseudo-registers.
Control flow is partially linearized, as graph nodes are now basic blocks instead of instructions.


\subsubsection{Branch Tunneling (LTL to LTL)}
Tunneling converts a sequence of jumps with no intermediate instructions into one long jump to the target.
In psuedocode:

\hbox{
\begin{lstlisting}
L1; nop; L2;
L2; nop; L3;
L3; nop; L4;
\end{lstlisting}\becomes\begin{lstlisting}
L1; nop; L4;
L2; nop; L4;
L3; nop; L4;
\end{lstlisting}
}

The \href{https://github.com/AbsInt/CompCert/blob/master/backend/Tunnelingproof.v#L407}{proof} is a forward simulation within LTL.
When the target cannot match a source transition, the target has \href{https://github.com/AbsInt/CompCert/blob/master/backend/Tunnelingproof.v#L257}{strictly fewer jumps} than the source.
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (LTL.semantics prog) (LTL.semantics tprog).
\end{lstlisting}


\subsubsection{Linearization (LTL to Linear)}
Linearization converts our LTL control-flow graph into a flat sequence of instructions.
Jump instructions replace the graph's edges, except where jumping gives the same result as falling through to the next instruction.

Minimizing the number of explicit jumps is an optimization challenge: pick an ordering on code blocks that maximizes the number of fall-throughs.
Once again, an OCaml \href{https://github.com/AbsInt/CompCert/blob/master/backend/Linearizeaux.ml}{procedure} applies a heuristic to pick a block ordering and a Coq function \href{https://github.com/AbsInt/CompCert/blob/master/backend/Linearize.v#L212}{folds over} the blocks to create a sequence of instructions.

The \href{https://github.com/AbsInt/CompCert/blob/master/backend/Linearizeproof.v#L739}{simulation proof} for this pass uses a \href{https://github.com/AbsInt/CompCert/blob/master/backend/Linearizeproof.v#L551}{measure} on the number of basic blocks in the program.
If the target cannot match a source transition, then the source transition must have just exited a block.
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (LTL.semantics prog) (Linear.semantics tprog).
\end{lstlisting}


\subsubsection{Label Pruning (Linear to Linear)}
Linearization always produces a label for each LTL node.
This pass removes unused labels.
(The extra labels could complicate future optimizations, but CompCert has \href{https://github.com/AbsInt/CompCert/blob/master/backend/CleanupLabels.v#L18}{none} of those yet.)

\href{https://github.com/AbsInt/CompCert/blob/master/backend/CleanupLabelsproof.v#L366}{Proof} is by forward simulation.
Target code \href{https://github.com/AbsInt/CompCert/blob/master/backend/CleanupLabelsproof.v#L252}{must match} each source step \href{https://github.com/AbsInt/CompCert/blob/master/backend/CleanupLabelsproof.v#L235}{or show} that the source transition moved forward along the current block.
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (Linear.semantics prog) (Linear.semantics tprog).
\end{lstlisting}


\subsubsection{Activation Record (Linear to Mach)}
This \href{https://github.com/AbsInt/CompCert/blob/master/backend/Stacking.v}{pass} conforms all call and return points in the linearized code to the target machine's calling conventions.

\href{https://github.com/AbsInt/CompCert/blob/master/backend/Stackingproof.v#L2923}{Proof} is by forward simulation, where each source transition is matched by \href{https://github.com/AbsInt/CompCert/blob/master/backend/Stackingproof.v#L2539}{one or more} target transitions.
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (Linear.semantics prog) (Mach.semantics return_address_offset tprog).
\end{lstlisting}


\subsubsection{Assembly Generation (Mach to Assembly)}
The final verified pass of the compiler produces an assembly AST.
There is one Coq implementation for each of the three possible backends: \href{https://github.com/AbsInt/CompCert/blob/master/powerpc/Asmgen.v}{PowerPC}, \href{https://github.com/AbsInt/CompCert/blob/master/arm/Asmgen.v}{ARM}, and \href{https://github.com/AbsInt/CompCert/blob/master/ia32/Asmgen.v}{\intel}.

The \href{https://github.com/AbsInt/CompCert/blob/master/ia32/Asmgenproof.v#L910}{proof} is by forward simulation; the correspondence between source and target is \href{https://github.com/AbsInt/CompCert/blob/master/ia32/Asmgenproof.v#L481}{nearly one-to-one}, but Mach \href{https://github.com/AbsInt/CompCert/blob/master/ia32/Asmgenproof.v#L472}{may take} an extra no-op step from a return state to the next state.
\begin{lstlisting}[style=Coq]
Theorem transf_program_correct:
  forward_simulation (Mach.semantics return_address_offset prog) (Asm.semantics tprog).
\end{lstlisting}


\newpage
\subsection{Assembly-End}
The final passes of the compiler turn a Coq model of assembly code into executable code.
These passes are unverified, though on PowerPC the \href{https://github.com/robbertkrebbers/compcert/blob/master/checklink/Check.ml#L3140}{cchecklink} tool will scan for basic translation errors like mangling a data segment or dropping function definition.


\subsubsection{Printing (Assembly to Text)}
An OCaml function \href{https://github.com/AbsInt/CompCert/blob/master/ia32/TargetPrinter.ml}{prints} the assembly AST, converting all the Coq constructors into register and instruction names.


\subsubsection{Assembling}
An external assembler collates the text into an object file.
On my machine, this is {\tt gcc}.


\subsubsection{Linking}
An external linker combines this object file with any others in the compilation pass, or with separately compiled files.
Again, my machine uses {\tt gcc}.

That's all there is to it!
